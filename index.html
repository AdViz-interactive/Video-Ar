<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>AdViz Smart AR - Wall & Floor Fixed</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Arial;
      background-color: #111;
      color: white;
      touch-action: none;
      user-select: none;
    }
    #overlay {
      position: absolute;
      top: 0; left: 0; width: 100%; height: 100%;
      pointer-events: none;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 100;
    }
    #setup-panel {
      pointer-events: auto;
      background: rgba(20, 20, 20, 0.95);
      padding: 24px;
      border-radius: 16px;
      text-align: center;
      border: 1px solid rgba(255, 255, 255, 0.1);
      max-width: 85%;
      box-shadow: 0 10px 40px rgba(0,0,0,0.6);
    }
    h1 { margin: 0 0 10px 0; font-size: 1.4rem; }
    p { color: #aaa; margin-bottom: 20px; font-size: 0.9rem; }
    .btn-primary {
      background-color: #4f46e5;
      color: white;
      padding: 12px 24px;
      border-radius: 8px;
      font-weight: 600;
      border: none;
      cursor: pointer;
      font-size: 1rem;
    }
    .file-wrapper {
      position: relative;
      display: inline-block;
      overflow: hidden;
      margin-bottom: 15px;
    }
    .file-wrapper input[type=file] {
      font-size: 100px;
      position: absolute;
      left: 0; top: 0; opacity: 0;
      cursor: pointer;
    }
    #status-msg { margin-top: 15px; font-size: 0.9rem; color: #888; }
    .success { color: #4ade80 !important; font-weight: bold; }
    #ar-btn-container {
      margin-top: 20px;
      height: 50px;
      display: flex;
      justify-content: center;
      pointer-events: auto;
    }
    button#ARButton {
      position: static !important;
      padding: 12px 30px !important;
      font-size: 16px !important;
      border-radius: 8px !important;
      background-color: #22c55e !important;
      color: white !important;
    }
    #feedback {
      position: absolute;
      top: 15%;
      background: rgba(0,0,0,0.7);
      padding: 10px 20px;
      border-radius: 30px;
      font-size: 14px;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.3s;
      z-index: 102;
    }
    #feedback.visible { opacity: 1; }
    #gesture-hint {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0,0,0,0.7);
      padding: 10px 20px;
      border-radius: 20px;
      font-size: 12px;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.3s;
      z-index: 102;
    }
    #gesture-hint.visible { opacity: 1; }
  </style>
</head>
<body>
  <div id="overlay">
    <div id="setup-panel">
      <h1>AdViz Smart AR</h1>
      <p>1. Upload Video<br>2. Tap START AR<br>3. Tap to Place on Wall/Floor</p>
      <div class="file-wrapper">
        <button class="btn-primary">üìÅ Choose Video</button>
        <input type="file" id="video-input" accept="video/*">
      </div>
      <div id="status-msg">Waiting for video...</div>
      <div id="ar-btn-container"></div>
    </div>
    <div id="feedback">Scanning surface...</div>
    <div id="gesture-hint" class="visible">Tap to place ‚Ä¢ Tap video to play/pause ‚Ä¢ Pinch to scale ‚Ä¢ Twist to rotate</div>
  </div>
  
  <video id="video-source" loop muted playsinline webkit-playsinline crossorigin="anonymous" style="display:none"></video>
  
  <script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
      "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
    }
  }
  </script>
  
  <script type="module">
    import * as THREE from 'three';
    import { ARButton } from 'three/addons/webxr/ARButton.js';
    
    let container, camera, scene, renderer;
    let controller, reticle;
    let hitTestSource = null;
    let hitTestSourceRequested = false;
    let videoElement, videoTexture, videoMesh;
    let isVideoPlaced = false;
    let videoAspect = 1.77;
    let videoHeight = 1.0;
    let currentSurfaceType = 'floor';
    
    // Touch/Gesture tracking
    let touchStartDistance = 0;
    let startScale = new THREE.Vector3();
    let isPinching = false;
    let lastTouchAngle = 0;
    
    const setupPanel = document.getElementById('setup-panel');
    const feedbackEl = document.getElementById('feedback');
    const statusMsg = document.getElementById('status-msg');
    const arContainer = document.getElementById('ar-btn-container');
    const gestureHintEl = document.getElementById('gesture-hint');
    const raycaster = new THREE.Raycaster();
    const tempMatrix = new THREE.Matrix4();
    
    init();
    animate();
    
    function init() {
      container = document.createElement('div');
      document.body.appendChild(container);
      
      scene = new THREE.Scene();
      scene.background = null;
      
      camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, 20);
      
      const light = new THREE.HemisphereLight(0xffffff, 0xbbbbff, 3);
      light.position.set(0.5, 1, 0.25);
      scene.add(light);
      
      renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
      renderer.setPixelRatio(1);
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.xr.enabled = true;
      container.appendChild(renderer.domElement);
      
      setupVideoInput();
      
      // Reticle
      reticle = new THREE.Mesh(
        new THREE.RingGeometry(0.15, 0.2, 32).rotateX(-Math.PI / 2),
        new THREE.MeshBasicMaterial({ color: 0xffffff })
      );
      reticle.matrixAutoUpdate = false;
      reticle.visible = false;
      scene.add(reticle);
      
      controller = renderer.xr.getController(0);
      controller.addEventListener('select', onSelect);
      scene.add(controller);
      
      window.addEventListener('resize', onWindowResize);
      
      renderer.domElement.addEventListener('touchstart', onTouchStart, { passive: false });
      renderer.domElement.addEventListener('touchmove', onTouchMove, { passive: false });
      renderer.domElement.addEventListener('touchend', onTouchEnd);
    }
    
    function setupVideoInput() {
      videoElement = document.getElementById('video-source');
      const input = document.getElementById('video-input');
      
      input.addEventListener('change', (e) => {
        const file = e.target.files[0];
        if (!file) return;
        
        statusMsg.textContent = "Loading...";
        statusMsg.className = "";
        
        videoElement.src = URL.createObjectURL(file);
        videoElement.onloadedmetadata = () => {
          statusMsg.textContent = "Ready! Tap START AR below.";
          statusMsg.className = "success";
          videoAspect = videoElement.videoWidth / videoElement.videoHeight;
          
          arContainer.innerHTML = '';
          const button = ARButton.createButton(renderer, {
            requiredFeatures: ['hit-test'],
            optionalFeatures: ['dom-overlay'],
            domOverlay: { root: document.getElementById('overlay') }
          });
          
          button.addEventListener('click', () => {
            setupPanel.style.display = 'none';
            createVideoMesh();
          });
          
          arContainer.appendChild(button);
        };
      });
    }
    
    function createVideoMesh() {
      videoTexture = new THREE.VideoTexture(videoElement);
      videoTexture.colorSpace = THREE.SRGBColorSpace;
      videoTexture.minFilter = THREE.LinearFilter;
      videoTexture.magFilter = THREE.LinearFilter;
      
      videoHeight = 1 / videoAspect;
      
      const geometry = new THREE.PlaneGeometry(1, videoHeight);
      geometry.translate(0, videoHeight / 2, 0);
      geometry.rotateX(-Math.PI / 2);
      
      const material = new THREE.MeshBasicMaterial({ 
        map: videoTexture, 
        side: THREE.DoubleSide 
      });
      
      videoMesh = new THREE.Mesh(geometry, material);
      videoMesh.visible = false;
      scene.add(videoMesh);
    }
    
    function detectSurfaceType(matrix) {
      // Extract Y-axis (up direction) from matrix
      const yAxis = new THREE.Vector3();
      yAxis.setFromMatrixColumn(matrix, 1);
      
      // If Y component is large, surface is horizontal (floor/ceiling)
      if (Math.abs(yAxis.y) > 0.7) {
        return 'floor';
      } else {
        return 'wall';
      }
    }
    
    function onSelect() {
      if (reticle.visible && !isVideoPlaced) {
        // PLACE VIDEO
        currentSurfaceType = detectSurfaceType(reticle.matrix);
        
        videoMesh.position.setFromMatrixPosition(reticle.matrix);
        
        if (currentSurfaceType === 'wall') {
          // For walls: use reticle rotation as-is (it's already perpendicular to wall)
          videoMesh.quaternion.setFromRotationMatrix(reticle.matrix);
          // Apply no additional rotation - it's already correct
        } else {
          // For floor: use reticle rotation (already correct from hit test)
          videoMesh.quaternion.setFromRotationMatrix(reticle.matrix);
        }
        
        videoMesh.visible = true;
        isVideoPlaced = true;
        videoElement.play();
        videoElement.muted = false;
        feedbackEl.classList.remove('visible');
        gestureHintEl.classList.add('visible');
        
        console.log('Placed on:', currentSurfaceType);
      } 
      else if (isVideoPlaced) {
        // TAP VIDEO - Play/Pause
        tempMatrix.identity().extractRotation(controller.matrixWorld);
        raycaster.ray.origin.setFromMatrixPosition(controller.matrixWorld);
        raycaster.ray.direction.set(0, 0, -1).applyMatrix4(tempMatrix);
        
        const intersects = raycaster.intersectObject(videoMesh);
        if (intersects.length > 0) {
          if (videoElement.paused) videoElement.play();
          else videoElement.pause();
        }
      }
    }
    
    function onTouchStart(e) {
      if (e.touches.length === 2 && isVideoPlaced) {
        isPinching = true;
        const touch0 = e.touches[0];
        const touch1 = e.touches[1];
        const dx = touch0.clientX - touch1.clientX;
        const dy = touch0.clientY - touch1.clientY;
        touchStartDistance = Math.sqrt(dx * dx + dy * dy);
        startScale.copy(videoMesh.scale);
        lastTouchAngle = Math.atan2(dy, dx);
        
        console.log('Pinch START - distance:', touchStartDistance);
        e.preventDefault();
      }
    }
    
    function onTouchMove(e) {
      if (!isVideoPlaced || !isPinching) return;
      if (e.touches.length !== 2) return;
      
      e.preventDefault();
      e.stopPropagation();
      
      const touch0 = e.touches[0];
      const touch1 = e.touches[1];
      const dx = touch0.clientX - touch1.clientX;
      const dy = touch0.clientY - touch1.clientY;
      const currentDist = Math.sqrt(dx * dx + dy * dy);
      const currentAngle = Math.atan2(dy, dx);
      
      // PINCH - Scale
      if (touchStartDistance > 10) {
        const scaleFactor = currentDist / touchStartDistance;
        const newScale = Math.max(0.2, Math.min(startScale.x * scaleFactor, 6.0));
        videoMesh.scale.setScalar(newScale);
        console.log('Scaling:', newScale.toFixed(2), 'factor:', scaleFactor.toFixed(2));
      }
      
      // ROTATE - Two-finger twist
      const angleDiff = currentAngle - lastTouchAngle;
      if (Math.abs(angleDiff) > 0.05) {
        videoMesh.rotateZ(angleDiff * 0.5);
        lastTouchAngle = currentAngle;
      }
    }
    
    function onTouchEnd(e) {
      if (e.touches.length < 2) {
        isPinching = false;
        console.log('Pinch END');
      }
    }
    
    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }
    
    function animate() {
      renderer.setAnimationLoop(render);
    }
    
    function render(timestamp, frame) {
      if (frame) {
        const session = renderer.xr.getSession();
        if (!session) return;
        
        if (!hitTestSourceRequested) {
          session.requestReferenceSpace('viewer').then((refSpace) => {
            session.requestHitTestSource({ space: refSpace }).then((source) => {
              hitTestSource = source;
            }).catch((err) => {});
          });
          
          session.addEventListener('end', () => {
            hitTestSourceRequested = false;
            hitTestSource = null;
            setupPanel.style.display = 'block';
            gestureHintEl.classList.remove('visible');
            videoElement.pause();
            videoMesh.visible = false;
            isVideoPlaced = false;
            feedbackEl.classList.remove('visible');
          });
          
          hitTestSourceRequested = true;
        }
        
        if (hitTestSource && !isVideoPlaced) {
          const hitTestResults = frame.getHitTestResults(hitTestSource);
          if (hitTestResults.length > 0) {
            const hit = hitTestResults[0];
            const refSpace = renderer.xr.getReferenceSpace();
            
            reticle.visible = true;
            reticle.matrix.fromArray(hit.getPose(refSpace).transform.matrix);
            
            const surfaceType = detectSurfaceType(reticle.matrix);
            feedbackEl.textContent = "Tap to Place (" + (surfaceType === 'wall' ? '\ud83d\udde7 WALL' : '\ud83d\udfe6 FLOOR') + ")";
            feedbackEl.classList.add('visible');
          } else {
            reticle.visible = false;
            feedbackEl.textContent = "Scan a surface...";
            feedbackEl.classList.add('visible');
          }
        } else if (isVideoPlaced) {
          feedbackEl.classList.remove('visible');
        }
      }
      
      renderer.render(scene, camera);
    }
  </script>
</body>
</html>
